<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Exported Authenticators in TLS</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 525px);
    width: 300px;
    z-index: 1;
  }
  #rfc\.toc {
    top: 15px;
  }
  ul.toc, nav#rfc\.toc {
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>ul.toc {
    top: 80px;
  }

  body {
    padding-right: 350px;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 25px auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
/*]]>*/</style>


  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Conventions and Terminology"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Authenticator Request"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Authenticator"/>
<link href="#rfc.section.5" rel="Chapter" title="5 API considerations"/>
<link href="#rfc.section.6" rel="Chapter" title="6 IANA Considerations"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Acknowledgements"/>
<link href="#rfc.references" rel="Chapter" title="9 References"/>
<link href="#rfc.references.1" rel="Chapter" title="9.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="9.2 Informative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Sullivan, N." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-tls-exported-authenticator-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-1-05" />
  <meta name="dct.abstract" content="This document describes a mechanism in Transport Layer Security (TLS) to provide an exportable proof of ownership of a certificate that can be transmitted out of band and verified by the other party." />
  <meta name="description" content="This document describes a mechanism in Transport Layer Security (TLS) to provide an exportable proof of ownership of a certificate that can be transmitted out of band and verified by the other party." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">TLS</td>
  <td class="right">N. Sullivan</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Cloudflare Inc.</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">January 05, 2018</td>
</tr>
<tr>
  <td class="left">Expires: July 9, 2018</td>
  <td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Exported Authenticators in TLS<br />
  <span class="filename">draft-ietf-tls-exported-authenticator-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document describes a mechanism in Transport Layer Security (TLS) to provide an exportable proof of ownership of a certificate that can be transmitted out of band and verified by the other party.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on July 9, 2018.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Conventions and Terminology</a></li>
<li>3.   <a href="#rfc.section.3">Authenticator Request</a></li>
<li>4.   <a href="#rfc.section.4">Authenticator</a></li>
<li>5.   <a href="#rfc.section.5">API considerations</a></li>
<li>6.   <a href="#rfc.section.6">IANA Considerations</a></li>
<li>7.   <a href="#rfc.section.7">Security Considerations</a></li>
<li>8.   <a href="#rfc.section.8">Acknowledgements</a></li>
<li>9.   <a href="#rfc.references">References</a></li>
<ul><li>9.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>9.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li><a href="#rfc.authors">Author's Address</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">This document provides a way to authenticate one party of a Transport Layer Security (TLS) communication to another using a certificate after the session has been established.  This allows both the client and server to prove ownership of additional identities at any time after the handshake has completed.  This proof of authentication can be exported and transmitted out of band from one party to be validated by the other party.</p>
<p id="rfc.section.1.p.2">This mechanism provides two advantages over the authentication that TLS natively provides:</p>
<p/>

<dl>
  <dt>multiple identities -</dt>
  <dd style="margin-left: 8">Endpoints that are authoritative for multiple identities - but do not have a single certificate that includes all of the identities - can authenticate with those identities over a single connection.</dd>
  <dt>spontaneous authentication -</dt>
  <dd style="margin-left: 8">Endpoints can authenticate after a connection is established, in response to events in a higher-layer protocol, as well as integrating more context.</dd>
</dl>
<p id="rfc.section.1.p.4">This document intends to replace much of the functionality of renegotiation in previous versions of TLS.  It has the advantages over renegotiation of not requiring additional on-the-wire changes during a connection.  For simplicity, only TLS 1.2 and later are supported.</p>
<p id="rfc.section.1.p.5">Post-handshake authentication is defined in TLS 1.3, but it has the disadvantage of requiring additional state to be stored in the TLS state machine and it composes poorly with multiplexed connection protocols like HTTP/2.  It is also only available for client authentication.  This mechanism is intended to be used as part of a replacement for post-handshake authentication in applications.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#conventions-and-terminology" id="conventions-and-terminology">Conventions and Terminology</a></h1>
<p id="rfc.section.2.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in RFC 2119 <a href="#RFC2119">[RFC2119]</a>.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#authenticator-request" id="authenticator-request">Authenticator Request</a></h1>
<p id="rfc.section.3.p.1">The authenticator request is a structured message that can be exported from either party of a TLS connection.  It can be transmitted to the other party of the TLS connection at the application layer.  The application layer protocol used to send the authenticator SHOULD use TLS as its underlying transport to keep the request confidential.</p>
<p id="rfc.section.3.p.2">An authenticator request message can be constructed by either the client or the server.  This authenticator request uses the CertificateRequest message structure from Section 4.3.2 of <a href="#TLS13">[TLS13]</a>.  This message does not include the TLS record layer and is therefore not encrypted with a handshake key.</p>
<pre>
 struct {
    opaque certificate_request_context&lt;0..2^8-1&gt;;
    Extension extensions&lt;2..2^16-1&gt;;
 } CertificateRequest;
</pre>
<p/>

<dl>
  <dt>CertificateRequest</dt>
  <dd style="margin-left: 8">This message is used to define the parameters in a request for an authenticator.  </dd>
  <dt>certificate_request_context</dt>
  <dd style="margin-left: 8">An opaque string which identifies the certificate request and which will be echoed in the authenticator message.  The certificate_request_context MUST be unique within the scope of this connection (thus preventing replay of authenticators). The certificate_request_context SHOULD be chosen to be unpredictable to the peer (e.g., by randomly generating it) in order to prevent an attacker who has temporary access to the peer&#8217;s private key from pre-computing valid authenticators.</dd>
  <dt>extensions</dt>
  <dd style="margin-left: 8">The extensions that are allowed in this structure include the extensions defined for CertificateRequest messages defined in Section 4.2. of <a href="#TLS13">[TLS13]</a> and the server_name <a href="#RFC6066">[RFC6066]</a> extension, which is allowed for client-generated authenticator requests.</dd>
</dl>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#authenticator" id="authenticator">Authenticator</a></h1>
<p id="rfc.section.4.p.1">The authenticator is a structured message that can be exported from either party of a TLS connection.  It can be transmitted to the other party of the TLS connection at the application layer.  The application layer protocol used to send the authenticator SHOULD use TLS as its underlying transport to keep the certificate confidential.</p>
<p id="rfc.section.4.p.2">An authenticator message can be constructed by either the client or the server given an established TLS connection, a certificate, and a corresponding private key.  For clients, an authenticator request is required; for servers an authenticator request is optional.  The authenticator uses the message structures from Section 4.4 of <a href="#TLS13">[TLS13]</a>, but different parameters.  These messages do not include the TLS record layer and are therefore not encrypted with a handshake key.</p>
<p id="rfc.section.4.p.3">Each authenticator is computed using a Handshake Context and Finished MAC Key derived from the TLS session.  These values are derived using an exporter as described in <a href="#RFC5705">[RFC5705]</a> (for TLS 1.2) or <a href="#TLS13">[TLS13]</a> (for TLS 1.3).  These values use different labels depending on the role of the sender:</p>
<p/>

<ul>
  <li>The Handshake Context is an exporter value that is derived using the label &#8220;EXPORTER-client authenticator handshake context&#8221; or &#8220;EXPORTER-server authenticator handshake context&#8221; for authenticators sent by the client and server respectively.</li>
  <li>The Finished MAC Key is an exporter value derived using the label &#8220;EXPORTER-client authenticator finished key&#8221; or &#8220;EXPORTER-server authenticator finished key&#8221; for authenticators sent by the client and server respectively.</li>
</ul>
<p id="rfc.section.4.p.5">The context_value used for the exporter is absent (length zero) for all four values. The length of the exported value is equal to the length of the output of the hash function selected in TLS for the pseudorandom function (PRF). Cipher suites that do not use the TLS PRF MUST define a hash function that can be used for this purpose or they cannot be used.</p>
<p id="rfc.section.4.p.6">If the connection is TLS 1.2, the master secret MUST have been computed with the extended master secret <a href="#RFC7627">[RFC7627]</a> to avoid key synchronization attacks.</p>
<p/>

<dl>
  <dt>Certificate</dt>
  <dd style="margin-left: 8">The certificate to be used for authentication and any supporting certificates in the chain. This structure is defined in <a href="#TLS13">[TLS13]</a>, Section 4.4.2.</dd>
</dl>
<p id="rfc.section.4.p.8">The certificate message contains an opaque string called certificate_request_context, which is extracted from the authenticator request if present.  If no authenticator request is provided, it is zero-length.</p>
<pre>
 struct {
    SignatureScheme algorithm;
    opaque signature&lt;0..2^16-1&gt;;
 } CertificateVerify;
</pre>
<p/>

<dl>
  <dt>CertificateVerify</dt>
  <dd style="margin-left: 8">This message is used to provide explicit proof that an endpoint possesses the private key corresponding to its certificate.  </dd>
</dl>
<p id="rfc.section.4.p.10">The algorithm field specifies the signature algorithm used (see Section 4.2.3 of <a href="#TLS13">[TLS13]</a> for the definition of this field).  The signature is a digital signature using that algorithm.  The signature scheme MUST be a valid signature scheme for TLS 1.3.  This excludes all RSASSA-PKCS1-v1_5 algorithms and ECDSA algorithms that are not supported in TLS 1.3.  If an authenticator request is present, the signature algorithm MUST be chosen from one of the signature schemes in the authenticator request.  Otherwise, the signature algorithm used should be chosen from the &#8220;signature_algorithms&#8221; extension of the ClientHello used in the connection handshake.</p>
<p id="rfc.section.4.p.11">The signature is computed using the over the concatenation of:</p>
<p/>

<ul>
  <li>A string that consists of octet 32 (0x20) repeated 64 times</li>
  <li>The context string &#8220;Exported Authenticator&#8221; (which is not NULL-terminated)</li>
  <li>A single 0 byte which serves as the separator</li>
  <li>If the authenticator request is present, the value <samp>Hash(Handshake Context || authenticator request || Certificate)</samp></li>
  <li>If an authenticator request is not present, the value <samp>Hash(Handshake Context || Certificate)</samp></li>
</ul>
<p id="rfc.section.4.p.13">where Hash is the hash function for the handshake.</p>
<p/>

<dl>
  <dt>Finished</dt>
  <dd style="margin-left: 8">A HMAC over the value Hash(Handshake Context || Certificate || CertificateVerify) if an authenticator is present, or Hash(Handshake Context || authenticator request || Certificate || CertificateVerify) where Hash is the hash function for the handshake, and the HMAC is computed using the hash function from the handshake and the Finished MAC Key as a key.</dd>
</dl>
<p id="rfc.section.4.p.15">The certificates chosen in the Certificate message MUST conform to the requirements of a Certificate message in the version of TLS negotiated.  If an authenticator request is present, the signature algorithms used to choose the algorithm are taken from the &#8220;signature_algorithms&#8221; in the from the authenticator.  If there is no authenticator request, the signature algorithms are chosen from the &#8220;signature_algorithms&#8221; extension from the ClientHello used in the connection.  This is described in Section 4.2.3 of <a href="#TLS13">[TLS13]</a> and Sections 7.4.2 and 7.4.6 of <a href="#RFC5246">[RFC5246]</a>.  Alternative certificate formats such as <a href="#RFC7250">[RFC7250]</a> Raw Public Keys are not supported.  The &#8220;server_name&#8221; <a href="#RFC6066">[RFC6066]</a>, &#8220;certificate_authorities&#8221; (Section 4.2.4. of <a href="#TLS13">[TLS13]</a>), or &#8220;oid_filters&#8221; (Section 4.2.5. of <a href="#TLS13">[TLS13]</a>) extensions are used to guide certificate selection, with the extensions provided in the authenticator request taking precedence over the extensions provided in the connection handshake.</p>
<p id="rfc.section.4.p.16">If an authenticator request was provided, the Certificate message MUST contain only extensions present in the authenticator request. Otherwise, the Certificate message MUST contain only extensions present in the ClientHello.</p>
<p id="rfc.section.4.p.17">The authenticator message is the concatenation of messages: Certificate || CertificateVerify || Finished</p>
<p id="rfc.section.4.p.18">A given authenticator can be validated by checking the validity of the CertificateVerify message given the authenticator request (if used) and recomputing the Finished message to see if it matches.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#api-considerations" id="api-considerations">API considerations</a></h1>
<p id="rfc.section.5.p.1">The creation and validation of both authenticator requests and authenticators SHOULD be implemented inside the TLS library even if it is possible to implement it at the application layer.  TLS implementations supporting the use of exported authenticators MUST provide application programming interfaces by which clients and servers may request and verify exported authenticator messages.</p>
<p id="rfc.section.5.p.2">Given an established connection, the application SHOULD be able to call the following APIs:</p>
<p id="rfc.section.5.p.3">&#8220;request&#8221;, which takes as input:</p>
<p/>

<ul>
  <li>certificate_request_context (from 0 to 255 bytes)</li>
  <li>set of extensions to include (this MUST include signature_algorithms)</li>
</ul>
<p id="rfc.section.5.p.5">It returns an authenticator request, which is a sequence of octets that includes a CertificateRequest message.</p>
<p id="rfc.section.5.p.6">&#8220;get context&#8221;, which takes as input</p>
<p/>

<ul>
  <li>authenticator</li>
</ul>
<p id="rfc.section.5.p.8">It returns the certificate_request_context.</p>
<p id="rfc.section.5.p.9">&#8220;authenticate&#8221;, which takes as input:</p>
<p/>

<ul>
  <li>a set of certificate chains and associated extensions (OCSP, SCT, etc.)</li>
  <li>a signer (either the private key associated with the certificate, or interface to perform private key operation) for each chain</li>
  <li>an optional authenticator request</li>
</ul>
<p id="rfc.section.5.p.11">It returns the exported authenticator as output.  It is RECOMMENDED that the logic for selecting the certificates and extensions to include in the exporter is implemented in the TLS library.  Implementing this in the TLS library lets the implementer take advantage of existing extension and certificate selection logic.</p>
<p id="rfc.section.5.p.12">It is also possible to implement this API outside of the TLS library using TLS exporters.  This may be preferable in cases where the application does not have access to a TLS library with these APIs or when TLS is handled independently of the application layer protocol.</p>
<p id="rfc.section.5.p.13">&#8220;validate&#8221;, which takes as input: * an optional authenticator request * an authenticator</p>
<p id="rfc.section.5.p.14">It returns the certificate chain and extensions.</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.6.p.1">This document has no IANA actions.</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#security" id="security">Security Considerations</a></h1>
<p id="rfc.section.7.p.1">The Certificate/Verify/Finished pattern intentionally looks like the TLS 1.3 pattern which now has been analyzed several times.  In the case where the client presents an authenticator to a server, <a href="#SIGMAC">[SIGMAC]</a> presents a relevant framework for analysis.</p>
<p id="rfc.section.7.p.2">Authenticators are independent and unidirectional. There is no explicit state change inside TLS when an authenticator is either created or validated.</p>
<p/>

<ul>
  <li>This property makes it difficult to formally prove that a server is jointly authoritative over multiple certificates, rather than individually authoritative over each.</li>
  <li>There is no indication in the TLS layer about which point in time an authenticator was computed.  Any feedback about the time of creation or validation of the authenticator should be tracked as part of the application layer semantics if required.</li>
</ul>
<p id="rfc.section.7.p.4">The signatures generated with this API cover the context string &#8220;Exported Authenticator&#8221; and therefore cannot be transplanted into other protocols.</p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#ack" id="ack">Acknowledgements</a></h1>
<p id="rfc.section.8.p.1">Comments on this proposal were provided by Martin Thomson.  Suggestions for <a href="#security">Section 7</a> were provided by Karthikeyan Bhargavan.</p>
<h1 id="rfc.references"><a href="#rfc.references">9.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">9.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5246">[RFC5246]</b>
      </td>
      <td class="top"><a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, DOI 10.17487/RFC5246, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5705">[RFC5705]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/rfc5705">Keying Material Exporters for Transport Layer Security (TLS)</a>", RFC 5705, DOI 10.17487/RFC5705, March 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6066">[RFC6066]</b>
      </td>
      <td class="top"><a>Eastlake 3rd, D.</a>, "<a href="http://tools.ietf.org/html/rfc6066">Transport Layer Security (TLS) Extensions: Extension Definitions</a>", RFC 6066, DOI 10.17487/RFC6066, January 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7250">[RFC7250]</b>
      </td>
      <td class="top"><a>Wouters, P.</a>, <a>Tschofenig, H.</a>, <a>Gilmore, J.</a>, <a>Weiler, S.</a> and <a>T. Kivinen</a>, "<a href="http://tools.ietf.org/html/rfc7250">Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</a>", RFC 7250, DOI 10.17487/RFC7250, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7627">[RFC7627]</b>
      </td>
      <td class="top"><a>Bhargavan, K.</a>, <a>Delignat-Lavaud, A.</a>, <a>Pironti, A.</a>, <a>Langley, A.</a> and <a>M. Ray</a>, "<a href="http://tools.ietf.org/html/rfc7627">Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension</a>", RFC 7627, DOI 10.17487/RFC7627, September 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="TLS13">[TLS13]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tls-tls13-22">The Transport Layer Security (TLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-tls13-22, November 2017.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">9.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="SIGMAC">[SIGMAC]</b>
      </td>
      <td class="top"><a>Krawczyk, H.</a>, "<a href="https://eprint.iacr.org/2016/711.pdf">A Unilateral-to-Mutual Authentication Compiler for Key Exchange (with Applications to Client Authentication in TLS 1.3)</a>", 2016.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Author's Address</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Nick Sullivan</span> 
	  <span class="n hidden">
		<span class="family-name">Sullivan</span>
	  </span>
	</span>
	<span class="org vcardline">Cloudflare Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:nick@cloudflare.com">nick@cloudflare.com</a></span>

  </address>
</div>

</body>
</html>
